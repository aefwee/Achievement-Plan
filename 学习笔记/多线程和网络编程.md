一.多线程

1.进程和线程

进程：是正在运行的程序

是系统进行资源分配和调用的独立单位

每一个进程都有它自己的内存空间和系统资源

线程：是进程中的单个顺序控制流，是一条执行路径。

单线程：一个进程如果只有一条执行路径，则称为单线程程序。

多线程：一个进程如果有多条执行路径，则称为多线程程序。


2.多线程的实现方式

方式1:继承Thread类：

定义一个类MyThread继承Thread类

在MyThread类中重写run()方法

创建MyThread类的对象

启动线程

两个小问题:

●为什么 要重写run()方法?

因为run()是用来封装被线程执行的代码

●run()方法和start()方法的区别?

run():封装线程执行的代码,直接调用,相当于普通方法的调用

start():启动线程;然后由JVM调用此线程的run()方法。

方式2:实现Runnable接口

●定义一个类MyRunnable实现Runnable接口

●在MyRunnable类中重写run()方法

●创建MyRunnable类的对象

●创建Thread类的对象，把MyRunnable对象作为构造方法的参数

●启动线程

多线程的实现方案有两种：

●继承Thread类

●实现Runnable接口

相比继承Thread类，实现Runnable接口的好处：

●避免了Java单继承的局限性

●适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离,较好的体现了面向对象的设计思想


3.设置和获取线程名称

Thread类中设置和获取线程名称的方法

●void setName(String name):将此线程的名称更改为等于参数name

●String getName():返回此线程的名称

●通过构造方法也可以设置线程名称

如何获取main()方法所在的线程名称?

●public static Thread currentThread0:返回对当前正在执行的线程对象的引用


4.线程调度

线程有两种调度模型

●分时调度模型: 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片

●抢占式调度模型:优先让优先级高的线程使用CPU,如果线程的优先级相同，那么会随机选择一个, 优先级高的线程获取的CPU时间片相对多一些

Java使用的是抢占式调度模型

假如计算机只有一个CPU,那么CPU在某一个时刻只能执行一条指令, 线程只有得到CPU时间片,也就是使用权,

可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的

Thread类中设置和获取线程优先级的方法

●public final int getPriority(): 返回此线程的优先级

●public final void setPriority(int newPriority):更改此线程的优先级

线程默认优先级是5;线程优先级的范围是: 1-10

线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多,或者多次运行的时候才能看到你想要的效果


5.线程控制

方法名,	说明

static void sleep(long millis),	使当前正在执行的线程停留 (暂停执行)指定的毫秒数

void join(),	等待这个线程死亡

void setDaemon(booleanon),	将此线程标记为守护线程， 当运行的线程都是守护线程时，Java虚拟机将退出


6.同步代码块

锁多条语句操作共享数据，可以使用同步代码块实现

●格式:

synchronized(任意对象) {

多条语句操作共享数据的代码

}

●synchronized(任意对象): 就相当于给代码加锁了,任意对象就可以看成是一把锁

同步的好处和弊端

●好处: 解决了多线程的数据安全问题

●弊端:当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。


7.同步方法

同步方法:就是把synchronized关键字加到方法上

●格式:

修饰符 synchronized 返回值类型 方法名(方法参数){ }

同步方法的锁对象是什么呢?

●this

同步静态方法:就是把synchronized关键字加到静态方法上

●格式: 

修饰符 static synchronized 返回值类型 方法名(方法参数) { }

同步静态方法的锁对象是什么呢?

●类名.class


8.线程安全的类

StringBuffer

●线程安全，可变的字符序列

●从版本JDK 5开始,被StringBuilder 替代。通常应该使用StringBuilder类, 因为它支持所有相同的操作，但它
更快，因为它不执行同步

Vector：

●从Java 2平台v1.2开始，该类改进了List接口,使其成为Java Collections Framework的成员。与新的集合实现
不同，Vector被同步。 如果不需要线程安全的实现，建议使用ArrayList代替Vector

Hashtable：

●该类实现了一个哈希表, 它将键映射到值。任何非null对象都可以用作键或者值

●从Java 2平台v1.2开始，该类进行了改进，实现了Map接口,使其成为Java Collections Framework的成员。

与新的集合实现不同，Hashtable被同步。 如果不需要线程安全的实现，建议使用HashMap代替Hashtabl。


9. Lock锁

虽然我们可以理解同步代码块和同步方法的锁对象问题，但我们没有接看在哪里加上了锁，在哪里释放了锁，
为更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

Lock实现提供比使用synchronized方法和语句可以获得更3广泛的锁定操作

Lock中提供了获得锁和释放锁的方法

●
void lock():获得锁

void unlock():释放锁

Lock是接口不能直接实例化，这里采用的实现类ReentrantLock来实例化

ReentrantLock的构造方法

●ReentrantLock():创建一个ReentrantLock的实例


10.生产者消费者模式概述

生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。

所谓生产者消费者问题，实际上包含了两类线程:

●一类是生产者线程用于生产数据

●一类是消费者线程用于消费数据

为了解耦生产者和消费者的关系,通常会采用共享的数据区域，就像是一个仓库

●生产者生产数据之后直接放置在公共数据区中，并不需要关心消费者的行为

●消费者只需要从共享数据区中获取数据,并不需要关心生产产者的行为

为了体现生产和消费过程中的等待和唤醒, Java就提供了几个方法供我们使用，这几个方法在Objec类中

Object类的等待和唤醒方法:

方法名，	说明

void wait()	，导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAII()方法

void notify()，	唤醒正在等待对象监视器的单个线程

void notifyAII()，	唤醒正在等待对象监视器的所有线程


二.网络编程

1.网络编程概述

网络编程：在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换。

网络编程三要素：

IP地址：

●要想让网络中的计算机能够互相通信,必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数
据的计算机和识别发送的计算机,而IP地址就这个标识号。就是设备的标识

端口：

●网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区
分这些应用程序呢?如果说IP地址可以唯一标识网络中的设备， 那么端口号就可以唯一标识设备中的应用程序
了。也就是应用程序的标识

协议：

●通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定
的规则，这就好比在道路中行驶的汽车一要遵交通规则一样。在计算机网络中，这些连接和通信的规则
被称为网络通信协议，它对数据的传输格式传输速率、传输步骤等做了统一规定, 通信双方必须同时遵守
才能完成数据交换。常见的协议有UDP协议和TCP协议


2. IP地址

IP地址:是网络中设备的唯一标识

IP地址分为两大类

●IPv4: 给每个连接在网络上的主机分配一个32bit地址。 按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit,也就是4个字节。例如一个采用二进制形式的IP地址是"11000000 10101000 00000001 01000010" ,这么长
的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用呢符号”.”分隔不同的字节。于是，上面的IP地址可以为"192.168.1.66" 。IP地址的这种表示法叫做”点分十进制表示法”,这显然比1和0容
易记忆得多。

●IPv6:由于互联网的蓬勃发展，IP地址的需求量愈来愈大,但是网络地址资源有限，使得IP的分配越发紧张。为扩大
地址空间，通过IPv6重新定义地址空间,采用128位地址长度,每16个字节一组,分成8组十六进制数,这样就解决了网
络地址资源数量不够的问题。

常用命令：

ipconfig：查看本机IP地址

ping IP地址：查看网络是否连通

特殊IP地址：

127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用。


3. InetAddress的使用

为了方便我们对IP地址的获取和操作，Java提供了一个类InetAddress供我们使用

InetAddress:此类表示Internet协议(IP) 地址

方法名	，说明

static InetAddress getByName(String host)，	确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址

String getHostName()，获取此IP地址的主机名

String getHostAddress()	，返回文本显示中的IP地址字符串

4.端口和协议

端口:设备上应用程序的唯标识

端口号:两个字节表示的整数，它的取值范围是0~65535。其中，0~ 1023之间的端口号用于知名的网
络服务和应用，普通的应用程序要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导
致当前程序启动失败。

协议:计算机网络中,连接和通信的规则被称为网络通信协议

UDP协议：

●用户数据报协议(User Datagram Protocol)

●UDP是无连接通信协议，即在数据传输时,数据的发送端和接收端不建立逻辑连接。简单来说，当计
算机向另外一台计算机发送数据时,发送端不会确认接收端是否存在,就会发出数据,同样接收端在收到
数据时，也不会向发送端反馈是否收到数据。

由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频视频和普通数据的传输。

●例如视频会议通常采用UDP协议， 因为这种情况即使偶丢失一两个数据包, 不会对接收结果产生大
影响。但是在使用UDP协议传送数据时,由于UDP的面向无连接性,不能保证数据的完整性,因此在传输
重要数据时不建议使用UDP协议。

TCP协议：

●传输控制协议 (Transmission Control Protocol)

●TCP协议是面向连接的通信协议，即传输数据之前,在发送端和接收端建立逻辑连接,然后再传输数据,
它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，客户端
向服务端发出连接请求，每次连接的创建都需要过"三次握手”

●三次握手: TCP协议中,在发送数据的准备阶段,客户端与服务器之间的三次交互，以保证连接的可靠

第一次握手,客户端向服务器端发出连接请诚,等待服务器确认

第二次握手，服务器端向客户端回送一个响应, 通知客户端收到了连接请求

第三次握手,客户端再次向服务器端发送确认信息,确认连接。

●完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性,
TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、 浏览网页等。


5.UDP通信程序

UDP通信原理：

UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象, 但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念

Java提供了DatagramSocket类作为基于UDP协议的Socket


UDP发送数据：

发送数据的步骤

①创建发送端的Socket对象(DatagramSocket)

DatagramSocket()

②创建数据, 并把数据打包

DatagramPacket(byte[] buf, int length, InetAddress address, int port)

③调用DatagramSocke对象的方法发送数据

void send(DatagramPacket p)

④关闭发送端

void close()


UDP接收数据：

接收数据的步骤

①创建接收端的Socket对象(DatagramSocket)

DatagramSocket(int port)

②创建一个数据包，用于接收数据

DatagramPacket(byte[] buf, int length)

③调用DatagramSocket对象的方法接收数据

void receive(DatagramPacket p)

④解析数据包, 并把数据在控制台显示

byte[] getData()

int getLength()

⑤关闭接收端

void close()


6.TCP通信程序

TCP通信原理：

TCP通信协议是一种可靠的网络协议， 它在通信的两端各建立一个Socket对象, 从而在通信的两端形成网络虚拟链路,一旦建立了虚拟的网络链路,两端的程序就可以通过虚拟链路进行通信

Java对基于TCP协议的的网络提供了良好的封装，使用Socke对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。

Java为客户端提供了Socket类,为服务器端提供了ServerSocket类。

TCP发送数据：

发送数据的步骤

①创建客户端的Socket对象(Socket)

Socket(String host, int port)

②获取输出流, 写数据

OutputStream getOutputStream()

③释放资源

void close()

TCP接收数据：

接收数据的步骤

①创建服务器端的Socket对象(ServerSocket)

ServerSocket(int port)

②监听客户端连接, 返回一个Socket对象

Socket accept()

③获取输入流，读数据,并把数据显示在控制台

InputStream getInputStream()

④释放资源

void close()
