一.多线程

1.进程和线程

进程：是正在运行的程序

是系统进行资源分配和调用的独立单位

每一个进程都有它自己的内存空间和系统资源

线程：是进程中的单个顺序控制流，是一条执行路径。

单线程：一个进程如果只有一条执行路径，则称为单线程程序。

多线程：一个进程如果有多条执行路径，则称为多线程程序。


2.多线程的实现方式

方式1:继承Thread类：

定义一个类MyThread继承Thread类

在MyThread类中重写run()方法

创建MyThread类的对象

启动线程

两个小问题:

●为什么 要重写run()方法?

因为run()是用来封装被线程执行的代码

●run()方法和start()方法的区别?

run():封装线程执行的代码,直接调用,相当于普通方法的调用

start():启动线程;然后由JVM调用此线程的run()方法。

方式2:实现Runnable接口

●定义一个类MyRunnable实现Runnable接口

●在MyRunnable类中重写run()方法

●创建MyRunnable类的对象

●创建Thread类的对象，把MyRunnable对象作为构造方法的参数

●启动线程

多线程的实现方案有两种：

●继承Thread类

●实现Runnable接口

相比继承Thread类，实现Runnable接口的好处：

●避免了Java单继承的局限性

●适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离,较好的体现了面向对象的设计思想


3.设置和获取线程名称

Thread类中设置和获取线程名称的方法

●void setName(String name):将此线程的名称更改为等于参数name

●String getName():返回此线程的名称

●通过构造方法也可以设置线程名称

如何获取main()方法所在的线程名称?

●public static Thread currentThread0:返回对当前正在执行的线程对象的引用


4.线程调度

线程有两种调度模型

●分时调度模型: 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片

●抢占式调度模型:优先让优先级高的线程使用CPU,如果线程的优先级相同，那么会随机选择一个, 优先级高的线程获取的CPU时间片相对多一些

Java使用的是抢占式调度模型

假如计算机只有一个CPU,那么CPU在某一个时刻只能执行一条指令, 线程只有得到CPU时间片,也就是使用权,

可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的

Thread类中设置和获取线程优先级的方法

●public final int getPriority(): 返回此线程的优先级

●public final void setPriority(int newPriority):更改此线程的优先级

线程默认优先级是5;线程优先级的范围是: 1-10

线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多,或者多次运行的时候才能看到你想要的效果


5.线程控制

方法名,	说明

static void sleep(long millis),	使当前正在执行的线程停留 (暂停执行)指定的毫秒数

void join(),	等待这个线程死亡

void setDaemon(booleanon),	将此线程标记为守护线程， 当运行的线程都是守护线程时，Java虚拟机将退出


6.同步代码块

锁多条语句操作共享数据，可以使用同步代码块实现

●格式:

synchronized(任意对象) {

多条语句操作共享数据的代码

}

●synchronized(任意对象): 就相当于给代码加锁了,任意对象就可以看成是一把锁

同步的好处和弊端

●好处: 解决了多线程的数据安全问题

●弊端:当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。


7.同步方法

同步方法:就是把synchronized关键字加到方法上

●格式:

修饰符 synchronized 返回值类型 方法名(方法参数){ }

同步方法的锁对象是什么呢?

●this

同步静态方法:就是把synchronized关键字加到静态方法上

●格式: 

修饰符 static synchronized 返回值类型 方法名(方法参数) { }

同步静态方法的锁对象是什么呢?

●类名.class


8.线程安全的类

StringBuffer

●线程安全，可变的字符序列

●从版本JDK 5开始,被StringBuilder 替代。通常应该使用StringBuilder类, 因为它支持所有相同的操作，但它
更快，因为它不执行同步

Vector：

●从Java 2平台v1.2开始，该类改进了List接口,使其成为Java Collections Framework的成员。与新的集合实现
不同，Vector被同步。 如果不需要线程安全的实现，建议使用ArrayList代替Vector

Hashtable：

●该类实现了一个哈希表, 它将键映射到值。任何非null对象都可以用作键或者值

●从Java 2平台v1.2开始，该类进行了改进，实现了Map接口,使其成为Java Collections Framework的成员。

与新的集合实现不同，Hashtable被同步。 如果不需要线程安全的实现，建议使用HashMap代替Hashtabl。